use crate::parser::{ArrayInfo, Expr, TypeName, Value, ValueType};
use std::{
    borrow::Cow,
    collections::{BTreeSet, VecDeque},
};

#[derive(Default)]
pub struct Generator {
    pub libs: BTreeSet<String>,
    lib_name: String,
}

#[derive(Debug)]
pub enum ExprType {
    Const(String),
    Variable(String),
}

impl Generator {
    pub fn new(lib_name: String) -> Self {
        Self {
            libs: Default::default(),
            lib_name,
        }
    }

    pub fn gen_msg<'a>(
        &mut self,
        module_name: &str,
        type_name: &'a str,
        exprs: &[Expr],
    ) -> VecDeque<Cow<'a, str>> {
        let mut lines = VecDeque::new();
        lines.push_back("use super::*;".into());
        lines.push_back("use safe_drive::msgs::*;".into());

        let mut const_val = Vec::new();
        let mut variables = Vec::new();

        for expr in exprs.iter() {
            match self.gen_expr(expr) {
                ExprType::Const(val) => const_val.push(val),
                ExprType::Variable(val) => variables.push(val),
            }
        }

        // generate constant values
        for c in const_val {
            lines.push_back(c.into());
        }

        if !variables.is_empty() {
            // generate C functions
            gen_cfun(&mut lines, module_name, type_name);

            // generate struct
            lines.push_back("".into());
            lines.push_back("#[repr(C)]".into());
            lines.push_back("#[derive(Debug)]".into());
            lines.push_back(format!("pub struct {type_name} {{").into());

            for v in variables {
                lines.push_back(v.into());
            }

            lines.push_back("}".into());

            // generate impl {type_name} and struct {type_name}Sequence
            gen_impl_and_seq(&mut lines, module_name, type_name);
        }

        for library in self.libs.iter() {
            let line = format!("use {}::*;", library);
            lines.push_front(line.into());
        }

        lines.push_front("// This file was automatically generated by ros2msg_to_rs (https://github.com/tier4/ros2msg_to_rs).".into());

        lines
    }

    fn gen_expr(&mut self, expr: &Expr) -> ExprType {
        match expr {
            Expr::Variable {
                type_name,
                var_name,
                value,
                comment,
            } => {
                let var_name = mangle_var_name(var_name.as_str());
                match value {
                    Some(ValueType::Const(val)) => {
                        let ty = self.gen_const_type(type_name);
                        let v = gen_value(val);
                        let result = if let Some(c) = comment {
                            format!("pub const {var_name}: {ty} = {v}; //{c}",)
                        } else {
                            format!("pub const {var_name}: {ty} = {v};",)
                        };
                        ExprType::Const(result)
                    }
                    _ => {
                        let ty = self.gen_type(type_name);
                        let result = if let Some(c) = comment {
                            format!("    pub {var_name}: {ty}, //{c}")
                        } else {
                            format!("    pub {var_name}: {ty},")
                        };
                        ExprType::Variable(result)
                    }
                }
            }
            _ => unreachable!(),
        }
    }

    fn gen_type(&mut self, type_name: &'_ TypeName) -> Cow<'_, str> {
        match type_name {
            TypeName::Type {
                type_name,
                array_info,
            } => {
                let type_str = if let Some(prim) = gen_primitives(type_name) {
                    prim.to_string()
                } else {
                    format!("super::{type_name}")
                };
                self.gen_array_type(None, type_str.into(), array_info)
            }
            TypeName::String(array_info) => {
                let type_str = "rosidl_runtime_c__String";
                self.gen_array_type(None, type_str.into(), array_info)
            }
            TypeName::LimitedString {
                size: _size,
                array_info,
            } => {
                let type_str = "rosidl_runtime_c__String";
                self.gen_array_type(None, type_str.into(), array_info)
            }
            TypeName::ScopedType {
                scope,
                type_name,
                array_info,
            } => {
                let type_str = if self.lib_name == *scope {
                    type_name.clone()
                } else {
                    match scope.as_ref() {
                        "std_msgs"
                        | "builtin_interfaces"
                        | "geometry_msgs"
                        | "unique_identifier_msgs"
                        | "sensor_msgs"
                        | "nav_msgs"
                        | "diagnostic_msgs" => {
                            format!("{scope}__msg__{type_name}")
                        }
                        _ => {
                            self.libs.insert(scope.clone());
                            format!("{scope}::msg::{type_name}")
                        }
                    }
                };

                let arr = self.gen_array_type(Some(scope.as_str()), type_str.into(), array_info);
                arr.into_owned().into()
            }
        }
    }

    fn gen_array_type<'a>(
        &mut self,
        scope: Option<&str>,
        type_str: Cow<'a, str>,
        array_info: &ArrayInfo,
    ) -> Cow<'a, str> {
        match array_info {
            ArrayInfo::Dynamic => gen_seq_type(scope, type_str).into(),
            ArrayInfo::Limited(_n) => gen_seq_type(scope, type_str).into(),
            ArrayInfo::Static(n) => format!("[{type_str}; {n}]").into(),
            ArrayInfo::NotArray => type_str.into(),
        }
    }

    fn gen_const_type(&mut self, type_name: &'_ TypeName) -> Cow<'_, str> {
        if let TypeName::String(array_info) = type_name {
            self.gen_array_type(None, "&[u8]".into(), array_info)
        } else {
            self.gen_type(type_name)
        }
    }
}

fn gen_value(value: &Value) -> String {
    format!("{value}")
}

fn gen_primitives(type_name: &str) -> Option<&str> {
    let t = match type_name {
        "bool" => "bool",
        "int8" => "i8",
        "uint8" => "u8",
        "int16" => "i16",
        "uint16" => "u16",
        "int32" => "i32",
        "uint32" => "u32",
        "int64" => "i64",
        "uint64" => "u64",
        "float32" => "f32",
        "float64" => "f64",
        _ => return None,
    };
    Some(t)
}

fn gen_seq_type<'a>(scope: Option<&str>, type_str: Cow<'a, str>) -> Cow<'a, str> {
    match type_str.as_ref() {
        "bool" => "rosidl_runtime_c__bool__Sequence".into(),
        "i8" => "rosidl_runtime_c__int8__Sequence".into(),
        "i16" => "rosidl_runtime_c__int16__Sequence".into(),
        "i32" => "rosidl_runtime_c__int32__Sequence".into(),
        "i64" => "rosidl_runtime_c__int64__Sequence".into(),
        "u8" => "rosidl_runtime_c__uint8__Sequence".into(),
        "u16" => "rosidl_runtime_c__uint16__Sequence".into(),
        "u32" => "rosidl_runtime_c__uint32__Sequence".into(),
        "u64" => "rosidl_runtime_c__uint64__Sequence".into(),
        "f32" => "rosidl_runtime_c__float32__Sequence".into(),
        "f64" => "rosidl_runtime_c__float64__Sequence".into(),
        "rosidl_runtime_c__String" => "rosidl_runtime_c__String__Sequence".into(),
        _ => match scope {
            Some(
                "std_msgs"
                | "builtin_interfaces"
                | "geometry_msgs"
                | "unique_identifier_msgs"
                | "sensor_msgs"
                | "nav_msgs"
                | "diagnostic_msgs",
            ) => format!("{type_str}__Sequence").into(),
            _ => format!("{type_str}Sequence").into(),
        },
    }
}

fn mangle_var_name(var_name: &str) -> Cow<'_, str> {
    match var_name {
        "type" | "pub" | "fn" | "match" | "if" | "while" | "break" | "continue" | "unsafe"
        | "async" | "move" | "trait" | "impl" | "for" => format!("{var_name}_").into(),
        _ => var_name.into(),
    }
}

fn gen_cfun(lines: &mut VecDeque<Cow<'_, str>>, module_name: &str, type_name: &str) {
    let cfun = format!(
        "
extern \"C\" {{
    fn {module_name}__msg__{type_name}__init(msg: *mut {type_name}) -> bool;
    fn {module_name}__msg__{type_name}__fini(msg: *mut {type_name});
    fn {module_name}__msg__{type_name}__Sequence__init(msg: *mut {type_name}Sequence, size: usize) -> bool;
    fn {module_name}__msg__{type_name}__Sequence__fini(msg: *mut {type_name}Sequence);
}}
"
    );
    lines.push_back(cfun.into());
}

fn gen_impl_and_seq(lines: &mut VecDeque<Cow<'_, str>>, module_name: &str, type_name: &str) {
    // generate impl and struct of sequence
    let impl_str = format!(
        "
impl {type_name} {{
    pub fn new() -> Option<Self> {{
        let mut msg: Self = unsafe {{ std::mem::MaybeUninit::zeroed().assume_init() }};
        if unsafe {{ {module_name}__msg__{type_name}__init(&mut msg) }} {{
            Some(msg)
        }} else {{
            None
        }}
    }}
}}

impl Drop for {type_name} {{
    fn drop(&mut self) {{
        unsafe {{ {module_name}__msg__{type_name}__fini(self) }};
    }}
}}

#[repr(C)]
#[derive(Debug)]
pub struct {type_name}Sequence {{
    data: *mut {type_name},
    size: usize,
    capacity: usize,
}}

impl {type_name}Sequence {{
    pub fn new(size: usize) -> Option<Self> {{
        let mut msg: Self = unsafe {{ std::mem::MaybeUninit::zeroed().assume_init() }};
        if unsafe {{ {module_name}__msg__{type_name}__Sequence__init(&mut msg, size) }} {{
            Some(msg)
        }} else {{
            None
        }}
    }}

    pub fn as_slice(&self) -> Option<&[StdMsg]> {{
        if self.data.is_null() {{
            None
        }} else {{
            let s = unsafe {{ std::slice::from_raw_parts(self.data, self.size) }};
            Some(s)
        }}
    }}

    pub fn as_slice_mut(&mut self) -> Option<&mut [StdMsg]> {{
        if self.data.is_null() {{
            None
        }} else {{
            let s = unsafe {{ std::slice::from_raw_parts_mut(self.data, self.size) }};
            Some(s)
        }}
    }}
}}

impl Drop for {type_name}Sequence {{
    fn drop(&mut self) {{
        unsafe {{ {module_name}__msg__{type_name}__Sequence__fini(self) }};
    }}
}}
"
    );

    lines.push_back(impl_str.into());
}
