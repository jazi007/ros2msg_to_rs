use crate::parser::{ArrayInfo, Expr, TypeName, Value, ValueType};
use std::{
    borrow::Cow,
    collections::{BTreeSet, VecDeque},
};

#[derive(Default)]
pub struct Generator {
    pub libs: BTreeSet<String>,
    lib_name: String,
    safe_drive_path: String,
    disable_common_interfaces: bool,
}

#[derive(Debug)]
pub enum ExprType {
    Const(String),
    Variable(String),
}

impl Generator {
    pub fn new(lib_name: String, safe_drive_path: String, disable_common_interfaces: bool) -> Self {
        Self {
            libs: Default::default(),
            lib_name,
            safe_drive_path,
            disable_common_interfaces,
        }
    }

    pub fn gen_msg<'a>(
        &mut self,
        module_name: &str,
        type_name: &'a str,
        exprs: &[Expr],
    ) -> VecDeque<Cow<'a, str>> {
        let mut lines = VecDeque::new();
        lines.push_back("use super::*;".into());
        lines.push_back("use super::super::super::*;".into());
        lines.push_back(format!("use {}::msg::*;", self.safe_drive_path).into());

        if !self.disable_common_interfaces {
            lines.push_back(
                format!("use {}::msg::common_interfaces::*;", self.safe_drive_path).into(),
            );
        }

        let mut const_val = Vec::new();
        let mut variables = Vec::new();

        for expr in exprs.iter() {
            match self.gen_expr(expr) {
                ExprType::Const(val) => const_val.push(val),
                ExprType::Variable(val) => variables.push(val),
            }
        }

        // generate constant values
        for c in const_val {
            lines.push_back(c.into());
        }

        if !variables.is_empty() {
            // generate C functions
            gen_cfun(&mut lines, module_name, type_name);

            // generate struct
            lines.push_back("".into());
            lines.push_back("#[repr(C)]".into());
            lines.push_back("#[derive(Debug)]".into());
            lines.push_back(format!("pub struct {type_name} {{").into());

            for v in variables {
                lines.push_back(v.into());
            }

            lines.push_back("}".into());

            // generate impl {type_name} and struct {type_name}Sequence
            gen_impl_and_seq(&mut lines, module_name, type_name);
        }

        lines.push_front("// This file was automatically generated by ros2msg_to_rs (https://github.com/tier4/ros2msg_to_rs).".into());

        lines
    }

    fn gen_expr(&mut self, expr: &Expr) -> ExprType {
        match expr {
            Expr::Variable {
                type_name,
                var_name,
                value,
                comment,
            } => {
                let var_name = crate::mangle(var_name.as_str());
                match value {
                    Some(ValueType::Const(val)) => {
                        let ty = self.gen_const_type(type_name);
                        let v = gen_value(val);
                        let result = if let Some(c) = comment {
                            format!("pub const {var_name}: {ty} = {v}; //{c}",)
                        } else {
                            format!("pub const {var_name}: {ty} = {v};",)
                        };
                        ExprType::Const(result)
                    }
                    _ => {
                        let ty = self.gen_type(type_name);
                        let result = if let Some(c) = comment {
                            format!("    pub {var_name}: {ty}, //{c}")
                        } else {
                            format!("    pub {var_name}: {ty},")
                        };
                        ExprType::Variable(result)
                    }
                }
            }
            _ => unreachable!(),
        }
    }

    fn gen_type(&mut self, type_name: &'_ TypeName) -> Cow<'_, str> {
        match type_name {
            TypeName::Type {
                type_name,
                array_info,
            } => {
                let type_str = if let Some(prim) = gen_primitives(type_name) {
                    prim.to_string()
                } else {
                    format!("{type_name}")
                };
                self.gen_array_type(None, type_str.into(), array_info)
            }
            TypeName::String(array_info) => {
                let type_str = format!("{}::msg::RosString<0>", self.safe_drive_path);
                self.gen_string_array_type(type_str.into(), 0, array_info)
            }
            TypeName::LimitedString { size, array_info } => {
                let type_str = format!("{}::msg::RosString<{size}>", self.safe_drive_path);
                self.gen_string_array_type(type_str.into(), *size, array_info)
            }
            TypeName::ScopedType {
                scope,
                type_name,
                array_info,
            } => {
                let type_str = if self.lib_name == *scope {
                    type_name.clone()
                } else {
                    match scope.as_ref() {
                        "builtin_interfaces" => {
                            format!("{scope}__msg__{type_name}")
                        }
                        _ => {
                            self.libs.insert(scope.clone());
                            format!("{scope}::msg::{type_name}")
                        }
                    }
                };

                let arr = self.gen_array_type(Some(scope.as_str()), type_str.into(), array_info);
                arr.into_owned().into()
            }
        }
    }

    fn gen_array_type<'a>(
        &mut self,
        scope: Option<&str>,
        type_str: Cow<'a, str>,
        array_info: &ArrayInfo,
    ) -> Cow<'a, str> {
        match array_info {
            ArrayInfo::Dynamic => self.gen_seq_type(scope, type_str, 0).into(),
            ArrayInfo::Limited(n) => self.gen_seq_type(scope, type_str, *n).into(),
            ArrayInfo::Static(n) => format!("[{type_str}; {n}]").into(),
            ArrayInfo::NotArray => type_str.into(),
        }
    }

    fn gen_string_array_type<'a>(
        &mut self,
        type_str: Cow<'a, str>,
        strlen: usize,
        array_info: &ArrayInfo,
    ) -> Cow<'a, str> {
        match array_info {
            ArrayInfo::Dynamic => {
                format!("{}::msg::RosStringSeq<{strlen}, 0>", self.safe_drive_path).into()
            }
            ArrayInfo::Limited(n) => {
                format!("{}::msg::RosStringSeq<{strlen}, {n}>", self.safe_drive_path).into()
            }
            ArrayInfo::Static(n) => format!("[{type_str}; {n}]").into(),
            ArrayInfo::NotArray => type_str.into(),
        }
    }

    fn gen_const_type(&mut self, type_name: &'_ TypeName) -> Cow<'_, str> {
        if let TypeName::String(array_info) = type_name {
            self.gen_array_type(None, "&[u8]".into(), array_info)
        } else {
            self.gen_type(type_name)
        }
    }

    fn gen_seq_type<'a>(
        &self,
        scope: Option<&str>,
        type_str: Cow<'a, str>,
        size: usize,
    ) -> Cow<'a, str> {
        match type_str.as_ref() {
            "bool" => format!("{}::msg::BoolSeq<{size}>", self.safe_drive_path).into(),
            "i8" => format!("{}::msg::I8Seq<{size}>", self.safe_drive_path).into(),
            "i16" => format!("{}::msg::I16Seq<{size}>", self.safe_drive_path).into(),
            "i32" => format!("{}::msg::I32Seq<{size}>", self.safe_drive_path).into(),
            "i64" => format!("{}::msg::I64Seq<{size}>", self.safe_drive_path).into(),
            "u8" => format!("{}::msg::U8Seq<{size}>", self.safe_drive_path).into(),
            "u16" => format!("{}::msg::U16Seq<{size}>", self.safe_drive_path).into(),
            "u32" => format!("{}::msg::U32Seq<{size}>", self.safe_drive_path).into(),
            "u64" => format!("{}::msg::U64Seq<{size}>", self.safe_drive_path).into(),
            "f32" => format!("{}::msg::F32Seq<{size}>", self.safe_drive_path).into(),
            "f64" => format!("{}::msg::F64Seq<{size}>", self.safe_drive_path).into(),
            _ => match scope {
                Some("builtin_interfaces") => format!(
                    "{}::msg::builtin_interfaces::{type_str}Seq",
                    self.safe_drive_path
                )
                .into(),
                _ => format!("{type_str}Sequence").into(),
            },
        }
    }
}

fn gen_value(value: &Value) -> String {
    format!("{value}")
}

fn gen_primitives(type_name: &str) -> Option<&str> {
    let t = match type_name {
        "bool" => "bool",
        "int8" => "i8",
        "uint8" => "u8",
        "int16" => "i16",
        "uint16" => "u16",
        "int32" => "i32",
        "uint32" => "u32",
        "int64" => "i64",
        "uint64" => "u64",
        "float32" => "f32",
        "float64" => "f64",
        "byte" => "u8",
        "char" => "i8",
        _ => return None,
    };
    Some(t)
}

fn gen_cfun(lines: &mut VecDeque<Cow<'_, str>>, module_name: &str, type_name: &str) {
    let cfun = format!(
        "
extern \"C\" {{
    fn {module_name}__msg__{type_name}__init(msg: *mut {type_name}) -> bool;
    fn {module_name}__msg__{type_name}__fini(msg: *mut {type_name});
    fn {module_name}__msg__{type_name}__Sequence__init(msg: *mut {type_name}Sequence, size: usize) -> bool;
    fn {module_name}__msg__{type_name}__Sequence__fini(msg: *mut {type_name}Sequence);
}}
"
    );
    lines.push_back(cfun.into());
}

fn gen_impl_and_seq(lines: &mut VecDeque<Cow<'_, str>>, module_name: &str, type_name: &str) {
    // generate impl and struct of sequence
    let impl_str = format!(
        "
impl {type_name} {{
    pub fn new() -> Option<Self> {{
        let mut msg: Self = unsafe {{ std::mem::MaybeUninit::zeroed().assume_init() }};
        if unsafe {{ {module_name}__msg__{type_name}__init(&mut msg) }} {{
            Some(msg)
        }} else {{
            None
        }}
    }}
}}

impl Drop for {type_name} {{
    fn drop(&mut self) {{
        unsafe {{ {module_name}__msg__{type_name}__fini(self) }};
    }}
}}

#[repr(C)]
#[derive(Debug)]
pub struct {type_name}Sequence {{
    data: *mut {type_name},
    size: usize,
    capacity: usize,
}}

impl {type_name}Sequence {{
    pub fn new(size: usize) -> Option<Self> {{
        let mut msg: Self = unsafe {{ std::mem::MaybeUninit::zeroed().assume_init() }};
        if unsafe {{ {module_name}__msg__{type_name}__Sequence__init(&mut msg, size) }} {{
            Some(msg)
        }} else {{
            None
        }}
    }}

    pub fn as_slice(&self) -> Option<&[{type_name}]> {{
        if self.data.is_null() {{
            None
        }} else {{
            let s = unsafe {{ std::slice::from_raw_parts(self.data, self.size) }};
            Some(s)
        }}
    }}

    pub fn as_slice_mut(&mut self) -> Option<&mut [{type_name}]> {{
        if self.data.is_null() {{
            None
        }} else {{
            let s = unsafe {{ std::slice::from_raw_parts_mut(self.data, self.size) }};
            Some(s)
        }}
    }}
}}

impl Drop for {type_name}Sequence {{
    fn drop(&mut self) {{
        unsafe {{ {module_name}__msg__{type_name}__Sequence__fini(self) }};
    }}
}}
"
    );

    lines.push_back(impl_str.into());
}
